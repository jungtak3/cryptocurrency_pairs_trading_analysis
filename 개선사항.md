# ì•”í˜¸í™”í í˜ì–´ íŠ¸ë ˆì´ë”© ì „ëµ ê°œì„  ë°©ì•ˆ

## ğŸš€ ìˆ˜ìµë¥  ê°œì„ ì„ ìœ„í•œ ì¢…í•© ì „ëµ

```mermaid
flowchart TD
    A["ğŸ“Š í˜„ì¬ ì „ëµ í•œê³„ì "] --> B["ğŸ“ˆ ìˆ˜ìµë¥  ê°œì„  ë°©ì•ˆ"]
    
    A --> A1["ğŸ”¹ ê³ ì • í—¤ì§€ë¹„ìœ¨<br/>ê³µì ë¶„ ê³„ìˆ˜ë§Œ ì‚¬ìš©"]
    A --> A2["ğŸ”¹ ë‹¨ìˆœí•œ ì§„ì…/ì²­ì‚°<br/>ì„ê³„ê°’ ê¸°ë°˜ë§Œ"]
    A --> A3["ğŸ”¹ ê±°ë˜ë¹„ìš© ë¯¸ë°˜ì˜<br/>ìŠ¬ë¦¬í”¼ì§€ ë¬´ì‹œ"]
    A --> A4["ğŸ”¹ ê³ ì • í¬ì§€ì…˜ ì‚¬ì´ì¦ˆ<br/>ë¦¬ìŠ¤í¬ ìµœì í™” ë¶€ì¡±"]
    A --> A5["ğŸ”¹ ì‹œì¥ ìƒí™© ë¬´ì‹œ<br/>ë³€ë™ì„± ì ì‘ ë¶€ì¡±"]
    
    B --> C1["ğŸ¯ ë™ì  í—¤ì§€ë¹„ìœ¨ ìµœì í™”"]
    B --> C3["âš–ï¸ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ê³ ë„í™”"]
    B --> C4["ğŸ’° ê±°ë˜ë¹„ìš© ìµœì í™”"]
    B --> C5["ğŸ“Š í¬íŠ¸í´ë¦¬ì˜¤ ë‹¤ê°í™”"]
    
    %% ë™ì  í—¤ì§€ë¹„ìœ¨ ìµœì í™”
    C1 --> D1["ğŸ“ˆ ë¡¤ë§ ìœˆë„ìš° í—¤ì§€ë¹„ìœ¨<br/>30ì¼/60ì¼/90ì¼ ë¹„êµ"]
    C1 --> D2["ğŸ”„ GARCH ê¸°ë°˜ ë™ì  ì¡°ì •<br/>ë³€ë™ì„± ë°˜ì˜"]
    C1 --> D3["ğŸ“Š Kalman Filter ì ìš©<br/>ì‹¤ì‹œê°„ ê³„ìˆ˜ ì—…ë°ì´íŠ¸"]
    
    %% ë¦¬ìŠ¤í¬ ê´€ë¦¬ ê³ ë„í™”
    C3 --> F1["ğŸ“‰ VaR ê¸°ë°˜ í¬ì§€ì…˜ ì‚¬ì´ì§•<br/>95%/99% ì‹ ë¢°êµ¬ê°„"]
    C3 --> F2["ğŸ›¡ï¸ ë™ì  ìŠ¤í†±ë¡œìŠ¤<br/>ATR ê¸°ë°˜ ì¡°ì •"]
    C3 --> F3["â° ì‹œê°„ ê¸°ë°˜ ì²­ì‚°<br/>í™€ë”© ê¸°ê°„ ì œí•œ"]
    C3 --> F4["ğŸ“Š ìµœëŒ€ ë“œë¡œìš°ë‹¤ìš´ ì œí•œ<br/>5%/10% ì œí•œì„ "]
    
    %% ê±°ë˜ë¹„ìš© ìµœì í™”
    C4 --> G1["âš–ï¸ ê±°ë˜ëŸ‰ ê¸°ë°˜ ìˆ˜ìˆ˜ë£Œ<br/>VIP ë“±ê¸‰ í™œìš©"]
    C4 --> G3["â±ï¸ ê±°ë˜ íƒ€ì´ë° ìµœì í™”<br/>ìœ ë™ì„± ë†’ì€ ì‹œê°„ëŒ€"]
    C4 --> G4["ğŸ”„ ë¦¬ë°¸ëŸ°ì‹± ë¹ˆë„ ì¡°ì •<br/>ë¹„ìš© vs ì„±ê³¼ ë°¸ëŸ°ìŠ¤"]
    
    %% í¬íŠ¸í´ë¦¬ì˜¤ ë‹¤ê°í™”
    C5 --> H1["ğŸ² ë‹¤ì¤‘ í˜ì–´ ì „ëµ<br/>6ê°œ â†’ 15ê°œ í˜ì–´"]
    C5 --> H3["â° ë‹¤ì¤‘ ì‹œê°„í”„ë ˆì„<br/>1ì‹œê°„/4ì‹œê°„/1ì¼"]
    
    %% ì„±ê³¼ ì¸¡ì •
    B --> I["ğŸ“Š ì„±ê³¼ ì¸¡ì • ì§€í‘œ"]
    I --> I1["ğŸ“ˆ ìƒ¤í”„ ë¹„ìœ¨ ê°œì„ <br/>ëª©í‘œ: >1.5"]
    I --> I2["ğŸ“‰ ìµœëŒ€ ë“œë¡œìš°ë‹¤ìš´<br/>ëª©í‘œ: <15%"]
    I --> I4["ğŸ’° ì—°ê°„ ìˆ˜ìµë¥ <br/>ëª©í‘œ: >30%"]
    
    %% ì‹¤í–‰ ë‹¨ê³„
    B --> J["ğŸš€ êµ¬í˜„ ë¡œë“œë§µ"]
    J --> J1["1ë‹¨ê³„: ë™ì  í—¤ì§€ë¹„ìœ¨<br/>4ì£¼ ë‚´ êµ¬í˜„"]
    J --> J2["2ë‹¨ê³„: ML ì‹ í˜¸ í†µí•©<br/>8ì£¼ ë‚´ êµ¬í˜„"]
    J --> J3["3ë‹¨ê³„: ë¦¬ìŠ¤í¬ ê´€ë¦¬<br/>12ì£¼ ë‚´ êµ¬í˜„"]
    J --> J4["4ë‹¨ê³„: ì „ëµ ë‹¤ê°í™”<br/>16ì£¼ ë‚´ êµ¬í˜„"]
    
    %% ìŠ¤íƒ€ì¼ë§
    style A fill:#ffebee
    style B fill:#e8f5e8
    style C1 fill:#e3f2fd
    style C2 fill:#f3e5f5
    style C3 fill:#fff3e0
    style C4 fill:#e0f2f1
    style C5 fill:#fce4ec
    style I fill:#e8eaf6
    style J fill:#f1f8e9
```

## ğŸ“‹ ìƒì„¸ ê°œì„  ì „ëµ

### 1. ğŸ¯ ë™ì  í—¤ì§€ë¹„ìœ¨ ìµœì í™”

#### í˜„ì¬ ë¬¸ì œì :
- ê³ ì •ëœ ê³µì ë¶„ ê³„ìˆ˜ ì‚¬ìš©
- ì‹œì¥ ë³€ë™ì„± ë³€í™” ë¯¸ë°˜ì˜
- ì¥ê¸°ê°„ ë™ì¼í•œ ë¹„ìœ¨ ìœ ì§€

#### ê°œì„  ë°©ì•ˆ:
```python
# ë¡¤ë§ ìœˆë„ìš° í—¤ì§€ë¹„ìœ¨
def dynamic_hedge_ratio(prices1, prices2, window=30):
    rolling_beta = []
    for i in range(window, len(prices1)):
        p1_window = prices1[i-window:i]
        p2_window = prices2[i-window:i]
        beta = calculate_ols_beta(p1_window, p2_window)
        rolling_beta.append(beta)
    return rolling_beta

# GARCH ê¸°ë°˜ ë™ì  ì¡°ì •
def garch_adjusted_ratio(returns1, returns2):
    # ì¡°ê±´ë¶€ ë¶„ì‚° ëª¨ë¸ë§
    # ë³€ë™ì„± í´ëŸ¬ìŠ¤í„°ë§ ë°˜ì˜
    pass
```

### 2. âš–ï¸ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ê³ ë„í™”

#### í˜„ì¬ ë¬¸ì œì :
- ê³ ì • í¬ì§€ì…˜ ì‚¬ì´ì¦ˆ
- ë“œë¡œìš°ë‹¤ìš´ ì œí•œ ì—†ìŒ
- ì‹œê°„ ê¸°ë°˜ ì²­ì‚° ë¶€ì¬

#### ê°œì„  ë°©ì•ˆ:
```python
# VaR ê¸°ë°˜ í¬ì§€ì…˜ ì‚¬ì´ì§•
def kelly_criterion_sizing(win_rate, avg_win, avg_loss):
    kelly_fraction = win_rate - (1 - win_rate) * (avg_loss / avg_win)
    return min(kelly_fraction, 0.25)  # ìµœëŒ€ 25% ì œí•œ

# ë™ì  ìŠ¤í†±ë¡œìŠ¤
def atr_stop_loss(prices, multiplier=2.0, period=14):
    atr = calculate_atr(prices, period)
    return prices[-1] - (atr * multiplier)
```

### 3. ğŸ’° ê±°ë˜ë¹„ìš© ìµœì í™”

#### í˜„ì¬ ë¬¸ì œì :
- ê±°ë˜ë¹„ìš© ë¯¸ê³ ë ¤
- ìŠ¬ë¦¬í”¼ì§€ ë¬´ì‹œ
- ë¹ˆë²ˆí•œ ë¦¬ë°¸ëŸ°ì‹±

#### ê°œì„  ë°©ì•ˆ:
```python
# ê±°ë˜ë¹„ìš© í¬í•¨ ìˆ˜ìµë¥ 
def net_return_after_costs(gross_return, trading_volume, 
                          fee_rate=0.001, slippage=0.0005):
    trading_cost = trading_volume * (fee_rate + slippage)
    return gross_return - trading_cost

# TWAP ì‹¤í–‰ ì•Œê³ ë¦¬ì¦˜
def twap_execution(target_quantity, duration_minutes=30):
    slice_size = target_quantity / duration_minutes
    # ì‹œê°„ ë¶„ì‚° ì‹¤í–‰ìœ¼ë¡œ ìŠ¬ë¦¬í”¼ì§€ ìµœì†Œí™”
```

### 4. ğŸ“Š í¬íŠ¸í´ë¦¬ì˜¤ ë‹¤ê°í™”

#### í˜„ì¬ ë¬¸ì œì :
- ì œí•œëœ í˜ì–´ ìˆ˜ (6ê°œ)
- ë‹¨ì¼ ì‹œê°„í”„ë ˆì„
- ë‹¨ìˆœí•œ ì „ëµ

#### ê°œì„  ë°©ì•ˆ:
```python
# ë‹¤ì¤‘ í˜ì–´ í¬íŠ¸í´ë¦¬ì˜¤
pairs_universe = [
    'BTC-ETH', 'BTC-LTC', 'BTC-NEO',
    'ETH-LTC', 'ETH-NEO', 'LTC-NEO',
    'BTC-ADA', 'ETH-DOT', 'BNB-SOL',
    'MATIC-AVAX', 'LINK-UNI', 'ATOM-NEAR'
]

# ë‹¤ì¤‘ ì‹œê°„í”„ë ˆì„
timeframes = ['1h', '4h', '1d']
for tf in timeframes:
    signals[tf] = generate_signals(data, timeframe=tf)

# ì‹ í˜¸ ì§‘ê³„
final_signal = weighted_average(signals)
```


## ğŸš€ êµ¬í˜„ ìš°ì„ ìˆœìœ„

1. **1ë‹¨ê³„**: ë™ì  í—¤ì§€ë¹„ìœ¨ êµ¬í˜„
3. **2ë‹¨ê³„**: ë¦¬ìŠ¤í¬ ê´€ë¦¬ ëª¨ë“ˆ ê°œë°œ
4. **3ë‹¨ê³„**: í¬íŠ¸í´ë¦¬ì˜¤ ë‹¤ê°í™” ì™„ì„±

ê° ë‹¨ê³„ë³„ë¡œ ë°±í…ŒìŠ¤íŠ¸ë¥¼ í†µí•œ ì„±ê³¼ ê²€ì¦ í›„ ë‹¤ìŒ ë‹¨ê³„ ì§„í–‰
